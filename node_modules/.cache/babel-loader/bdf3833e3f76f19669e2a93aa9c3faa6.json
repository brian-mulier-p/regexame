{"ast":null,"code":"import _classCallCheck from \"C:/Users/bmmul/IdeaProjects/regexame/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/bmmul/IdeaProjects/regexame/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"C:/Users/bmmul/IdeaProjects/regexame/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/Users/bmmul/IdeaProjects/regexame/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Transport } from \"../transport.js\";\nimport yeast from \"yeast\";\nimport parseqs from \"parseqs\";\nimport { encodePayload, decodePayload } from \"engine.io-parser\";\nexport var Polling = /*#__PURE__*/function (_Transport) {\n  _inherits(Polling, _Transport);\n\n  var _super = _createSuper(Polling);\n\n  function Polling() {\n    var _this;\n\n    _classCallCheck(this, Polling);\n\n    _this = _super.apply(this, arguments);\n    _this.polling = false;\n    return _this;\n  }\n  /**\r\n   * Transport name.\r\n   */\n\n\n  _createClass(Polling, [{\n    key: \"name\",\n    get: function get() {\n      return \"polling\";\n    }\n    /**\r\n     * Opens the socket (triggers polling). We write a PING message to determine\r\n     * when the transport is open.\r\n     *\r\n     * @api private\r\n     */\n\n  }, {\n    key: \"doOpen\",\n    value: function doOpen() {\n      this.poll();\n    }\n    /**\r\n     * Pauses polling.\r\n     *\r\n     * @param {Function} callback upon buffers are flushed and transport is paused\r\n     * @api private\r\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause(onPause) {\n      var _this2 = this;\n\n      this.readyState = \"pausing\";\n\n      var pause = function pause() {\n        _this2.readyState = \"paused\";\n        onPause();\n      };\n\n      if (this.polling || !this.writable) {\n        var total = 0;\n\n        if (this.polling) {\n          total++;\n          this.once(\"pollComplete\", function () {\n            --total || pause();\n          });\n        }\n\n        if (!this.writable) {\n          total++;\n          this.once(\"drain\", function () {\n            --total || pause();\n          });\n        }\n      } else {\n        pause();\n      }\n    }\n    /**\r\n     * Starts polling cycle.\r\n     *\r\n     * @api public\r\n     */\n\n  }, {\n    key: \"poll\",\n    value: function poll() {\n      this.polling = true;\n      this.doPoll();\n      this.emit(\"poll\");\n    }\n    /**\r\n     * Overloads onData to detect payloads.\r\n     *\r\n     * @api private\r\n     */\n\n  }, {\n    key: \"onData\",\n    value: function onData(data) {\n      var _this3 = this;\n\n      var callback = function callback(packet) {\n        // if its the first message we consider the transport open\n        if (\"opening\" === _this3.readyState && packet.type === \"open\") {\n          _this3.onOpen();\n        } // if its a close packet, we close the ongoing requests\n\n\n        if (\"close\" === packet.type) {\n          _this3.onClose();\n\n          return false;\n        } // otherwise bypass onData and handle the message\n\n\n        _this3.onPacket(packet);\n      }; // decode payload\n\n\n      decodePayload(data, this.socket.binaryType).forEach(callback); // if an event did not trigger closing\n\n      if (\"closed\" !== this.readyState) {\n        // if we got data we're not polling\n        this.polling = false;\n        this.emit(\"pollComplete\");\n\n        if (\"open\" === this.readyState) {\n          this.poll();\n        } else {}\n      }\n    }\n    /**\r\n     * For polling, send a close packet.\r\n     *\r\n     * @api private\r\n     */\n\n  }, {\n    key: \"doClose\",\n    value: function doClose() {\n      var _this4 = this;\n\n      var close = function close() {\n        _this4.write([{\n          type: \"close\"\n        }]);\n      };\n\n      if (\"open\" === this.readyState) {\n        close();\n      } else {\n        // in case we're trying to close while\n        // handshaking is in progress (GH-164)\n        this.once(\"open\", close);\n      }\n    }\n    /**\r\n     * Writes a packets payload.\r\n     *\r\n     * @param {Array} data packets\r\n     * @param {Function} drain callback\r\n     * @api private\r\n     */\n\n  }, {\n    key: \"write\",\n    value: function write(packets) {\n      var _this5 = this;\n\n      this.writable = false;\n      encodePayload(packets, function (data) {\n        _this5.doWrite(data, function () {\n          _this5.writable = true;\n\n          _this5.emit(\"drain\");\n        });\n      });\n    }\n    /**\r\n     * Generates uri for connection.\r\n     *\r\n     * @api private\r\n     */\n\n  }, {\n    key: \"uri\",\n    value: function uri() {\n      var query = this.query || {};\n      var schema = this.opts.secure ? \"https\" : \"http\";\n      var port = \"\"; // cache busting is forced\n\n      if (false !== this.opts.timestampRequests) {\n        query[this.opts.timestampParam] = yeast();\n      }\n\n      if (!this.supportsBinary && !query.sid) {\n        query.b64 = 1;\n      } // avoid port if default for schema\n\n\n      if (this.opts.port && (\"https\" === schema && Number(this.opts.port) !== 443 || \"http\" === schema && Number(this.opts.port) !== 80)) {\n        port = \":\" + this.opts.port;\n      }\n\n      var encodedQuery = parseqs.encode(query);\n      var ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\n      return schema + \"://\" + (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) + port + this.opts.path + (encodedQuery.length ? \"?\" + encodedQuery : \"\");\n    }\n  }]);\n\n  return Polling;\n}(Transport);","map":{"version":3,"sources":["C:/Users/bmmul/IdeaProjects/regexame/node_modules/engine.io-client/build/esm/transports/polling.js"],"names":["Transport","yeast","parseqs","encodePayload","decodePayload","Polling","arguments","polling","poll","onPause","readyState","pause","writable","total","once","doPoll","emit","data","callback","packet","type","onOpen","onClose","onPacket","socket","binaryType","forEach","close","write","packets","doWrite","query","schema","opts","secure","port","timestampRequests","timestampParam","supportsBinary","sid","b64","Number","encodedQuery","encode","ipv6","hostname","indexOf","path","length"],"mappings":"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","sourcesContent":["import { Transport } from \"../transport.js\";\r\nimport yeast from \"yeast\";\r\nimport parseqs from \"parseqs\";\r\nimport { encodePayload, decodePayload } from \"engine.io-parser\";\r\nexport class Polling extends Transport {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.polling = false;\r\n    }\r\n    /**\r\n     * Transport name.\r\n     */\r\n    get name() {\r\n        return \"polling\";\r\n    }\r\n    /**\r\n     * Opens the socket (triggers polling). We write a PING message to determine\r\n     * when the transport is open.\r\n     *\r\n     * @api private\r\n     */\r\n    doOpen() {\r\n        this.poll();\r\n    }\r\n    /**\r\n     * Pauses polling.\r\n     *\r\n     * @param {Function} callback upon buffers are flushed and transport is paused\r\n     * @api private\r\n     */\r\n    pause(onPause) {\r\n        this.readyState = \"pausing\";\r\n        const pause = () => {\r\n            this.readyState = \"paused\";\r\n            onPause();\r\n        };\r\n        if (this.polling || !this.writable) {\r\n            let total = 0;\r\n            if (this.polling) {\r\n                total++;\r\n                this.once(\"pollComplete\", function () {\r\n                    --total || pause();\r\n                });\r\n            }\r\n            if (!this.writable) {\r\n                total++;\r\n                this.once(\"drain\", function () {\r\n                    --total || pause();\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            pause();\r\n        }\r\n    }\r\n    /**\r\n     * Starts polling cycle.\r\n     *\r\n     * @api public\r\n     */\r\n    poll() {\r\n        this.polling = true;\r\n        this.doPoll();\r\n        this.emit(\"poll\");\r\n    }\r\n    /**\r\n     * Overloads onData to detect payloads.\r\n     *\r\n     * @api private\r\n     */\r\n    onData(data) {\r\n        const callback = packet => {\r\n            // if its the first message we consider the transport open\r\n            if (\"opening\" === this.readyState && packet.type === \"open\") {\r\n                this.onOpen();\r\n            }\r\n            // if its a close packet, we close the ongoing requests\r\n            if (\"close\" === packet.type) {\r\n                this.onClose();\r\n                return false;\r\n            }\r\n            // otherwise bypass onData and handle the message\r\n            this.onPacket(packet);\r\n        };\r\n        // decode payload\r\n        decodePayload(data, this.socket.binaryType).forEach(callback);\r\n        // if an event did not trigger closing\r\n        if (\"closed\" !== this.readyState) {\r\n            // if we got data we're not polling\r\n            this.polling = false;\r\n            this.emit(\"pollComplete\");\r\n            if (\"open\" === this.readyState) {\r\n                this.poll();\r\n            }\r\n            else {\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * For polling, send a close packet.\r\n     *\r\n     * @api private\r\n     */\r\n    doClose() {\r\n        const close = () => {\r\n            this.write([{ type: \"close\" }]);\r\n        };\r\n        if (\"open\" === this.readyState) {\r\n            close();\r\n        }\r\n        else {\r\n            // in case we're trying to close while\r\n            // handshaking is in progress (GH-164)\r\n            this.once(\"open\", close);\r\n        }\r\n    }\r\n    /**\r\n     * Writes a packets payload.\r\n     *\r\n     * @param {Array} data packets\r\n     * @param {Function} drain callback\r\n     * @api private\r\n     */\r\n    write(packets) {\r\n        this.writable = false;\r\n        encodePayload(packets, data => {\r\n            this.doWrite(data, () => {\r\n                this.writable = true;\r\n                this.emit(\"drain\");\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Generates uri for connection.\r\n     *\r\n     * @api private\r\n     */\r\n    uri() {\r\n        let query = this.query || {};\r\n        const schema = this.opts.secure ? \"https\" : \"http\";\r\n        let port = \"\";\r\n        // cache busting is forced\r\n        if (false !== this.opts.timestampRequests) {\r\n            query[this.opts.timestampParam] = yeast();\r\n        }\r\n        if (!this.supportsBinary && !query.sid) {\r\n            query.b64 = 1;\r\n        }\r\n        // avoid port if default for schema\r\n        if (this.opts.port &&\r\n            ((\"https\" === schema && Number(this.opts.port) !== 443) ||\r\n                (\"http\" === schema && Number(this.opts.port) !== 80))) {\r\n            port = \":\" + this.opts.port;\r\n        }\r\n        const encodedQuery = parseqs.encode(query);\r\n        const ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\r\n        return (schema +\r\n            \"://\" +\r\n            (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) +\r\n            port +\r\n            this.opts.path +\r\n            (encodedQuery.length ? \"?\" + encodedQuery : \"\"));\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}